// HP Prime program to render John Conway's Game of Life on the screen
// In this first revision, always starts with an R-Pentomino

// Load the r pentomino in the middle of the matrix
// Assumes matrix is set to 0's
LoadRPentomino(CurrentGen)
BEGIN
  LOCAL MatSize, MidX, MidY;

  MatSize := SIZE(CurrentGen);

  MidX := CEILING(MatSize(2)/2); // Middle of columns
  MidY := CEILING(MatSize(1)/2); // Middle of rows

  // Creates the R-pentomino pattern in the matrix middle 
  //
  //           **
  //          **
  //           *
  // Matrices are Row, Col which maps to Y,X
  CurrentGen(MidY,MidX) := 1;
  CurrentGen(MidY-1,MidX) := 1;
  CurrentGen(MidY-1,MidX+1) := 1;
  CurrentGen(MidY,MidX-1) := 1;
  CurrentGen(MidY+1,MidX) := 1;

  RETURN(CurrentGen);
END;

// Render the pixel matrix on the screen as a grid of squares
RenderMatrix(CurrentGen)
BEGIN
    LOCAL MatSize, BoardX, BoardY, RenderX, RenderY, edgecolor, fillcolor; 

    MatSize := SIZE(CurrentGen);
    HAngle:=0; AAngle:=0; // set current angle mode
     Xmin:= 0;  Xmax:= MatSize(2)+1;  Ymin:=0;  Ymax:=MatSize(1)+1; //set default Cartesian window values
     //RECT(); //clear screen

     edgecolor := RGB(255,0,255);
     fillcolor := RGB(255,0,0);
     FOR BoardX FROM 1 TO MatSize(2) DO
        RenderX := Xmax - BoardX;
        FOR BoardY FROM 1 TO MatSize(1) DO
            RenderY := Ymax - BoardY;
            IF CurrentGen(BoardY, BoardX) == 1 THEN
                 RECT(G0, RenderX - 1, RenderY - 1, RenderX, RenderY, edgecolor, fillcolor);
            ELSE
                 RECT(G0, RenderX - 1, RenderY - 1, RenderX, RenderY, RGB(255,255,255), RGB(255,255,255)); 
            END;
        END;
     END;
END;

// Implementation of John Conway's game of life
//  1  Any live cell with two or three live neighbours survives.
//  2  Any dead cell with three live neighbours becomes a live cell.
//  3  All other live cells die in the next generation. 
//     Similarly, all other dead cells stay dead.
//
GetNextGeneration(CurrentGen)
BEGIN
  LOCAL MatSize;
  LOCAL BoardX;
  LOCAL BoardY;
  LOCAL NextGen;  
  LOCAL NbrTlRow, NbrTlCol, NbrBrRow, NbrBrCol, Nbrs, NbrCount;
  LOCAL LiveCellCount;
  LOCAL CurrentCell;
  LOCAL BlankCheckSum; // Used when checking for a range of blank rows or columns when skipping for optimization
  LOCAL SubMatrixOpt; // When building a matrix to check to see if all zeros duing optimization

  MatSize := SIZE(CurrentGen);
  NextGen := MAKEMAT(0, MatSize(1), MatSize(2));
  // Simple for loop for now, will optimize later

  FOR BoardX FROM 1 TO MatSize(2) DO
    NbrTlCol := BoardX - 1;
    NbrBrCol := BoardX + 1;

    IF NbrTlCol == 0 THEN
      NbrTlCol := 1;
    END;
    IF NbrBrCol > MatSize(2) THEN
      NbrBrCol := MatSize(2);
    END;

    // Scan for a blank group of columns and skip them (optimization to speed up generation calculation, if they are all blank, they will stay blank)
    SubMatrixOpt  := CurrentGen({{1,NbrTlCol},{MatSize(1),NbrBrCol}});
    BlankCheckSum := SLIST(SubMatrixOpt);  
    IF BlankCheckSum > 0 THEN  
      FOR BoardY FROM 1 TO MatSize(1) DO
        NbrTlRow := BoardY - 1;
        NbrBrRow := BoardY + 1;
    
        CurrentCell := CurrentGen(BoardY, BoardX);  

        // If we hit the edges in either direction, fix up 
        // references (assume outer cells are always off
        IF NbrTlRow == 0 THEN
          NbrTlRow := 1;
        END;

        IF NbrBrRow > MatSize(1) THEN
          NbrBrRow := MatSize(1);
        END;

        // PRINT("TL Row " + NbrTlRow + " TL Col " + NbrTlCol + " BR Row " + NbrBrRow + " BR Col " + NbrBrCol);
        Nbrs := CurrentGen({{NbrTlRow,NbrTlCol},{NbrBrRow,NbrBrCol}});
        NbrCount := SLIST(Nbrs)-CurrentCell; 

        NextGen(BoardY, BoardX) := 0;  

        IF CurrentCell > 0 THEN
          IF (NbrCount == 2 OR NbrCount == 3) THEN 
            NextGen(BoardY, BoardX) := 1;  
          ELSE
            NextGen(BoardY, BoardX) := 0;  
          END;
        ELSE
          IF (NbrCount == 3) THEN
            NextGen(BoardY, BoardX) := 1;
          END;
        END;
      END;
    END;
  END;

  RETURN(NextGen);
END;

/// MAIN
EXPORT GameOfLife()
BEGIN
   // Size of playing field (square matrix)
   LOCAL FieldSize;
   
   // Frame counter  
   LOCAL RenderFrame;

   //TODO load this from a user prompt
   INPUT(FieldSize);
 

   // SIZE X SIZE matrix of current generation 
   // (this is the generation visible on the screen)
   LOCAL CurrentGen;

   // SIZE x SIZE matrix of next generation. Once computed
   // becomes the current generation and then is zeroed out 
   LOCAL NextGen;

   // Create both  current and next gen matrices as 0 matrices
   CurrentGen := MAKEMAT(0, FieldSize, FieldSize);
   NextGen := MAKEMAT(0, FieldSize, FieldSize);

   CurrentGen := LoadRPentomino(CurrentGen);
 
   STARTAPP("Function"); // Start function app. The next variables set are graphing app variables and do not exist for apps with no graphing capabilty.
   STARTVIEW(-1); // set home screen because STARTAPP opens the default view for the app
   RECT();
   
   FOR RenderFrame FROM 1 TO 50 DO
      RenderMatrix(CurrentGen);
      CurrentGen := GetNextGeneration(CurrentGen);
      WAIT(0.05);
   END;

   WAIT();
   RETURN(0);
END;
