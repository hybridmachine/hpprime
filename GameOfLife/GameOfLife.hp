// HP Prime program to render John Conway's Game of Life on the screen
// In this first revision, always starts with an R-Pentomino

// Load the r pentomino in the middle of the matrix
// Assumes matrix is set to 0's
LoadRPentomino(CurrentGen)
BEGIN
	LOCAL MatSize, MidX, MidY;

	MatSize := SIZE(CurrentGen);

	MidX := CEILING(MatSize(2)/2); // Middle of columns
	MidY := CEILING(MatSize(1)/2); // Middle of rows

	// Creates the R-pentomino pattern in the matrix middle 
	//
	//           **
	//          **
	//           *
	// Matrices are Row, Col which maps to Y,X
	CurrentGen(MidY,MidX) := 1;
	CurrentGen(MidY-1,MidX) := 1;
	CurrentGen(MidY-1,MidX+1) := 1;
	CurrentGen(MidY,MidX-1) := 1;
	CurrentGen(MidY+1,MidX) := 1;

	RETURN(CurrentGen);
END;

// Implementation of John Conway's game of life
//  1  Any live cell with two or three live neighbours survives.
//  2  Any dead cell with three live neighbours becomes a live cell.
//  3  All other live cells die in the next generation. 
//     Similarly, all other dead cells stay dead.
//
GetNextGeneration(CurrentGen)
BEGIN
	LOCAL MatSize;
	LOCAL BoardX;
	LOCAL BoardY;
	LOCAL NextGen;	
	LOCAL NbrTlRow, NbrTlCol, NbrBrRow, NbrBrCol, Nbrs;
	LOCAL LiveCellCount;
	LOCAL CurrentCell;


	MatSize := SIZE(CurrentGen);
	NextGen := MAKEMAT(0, MatSize(1), MatSize(2));
	// Simple for loop for now, will optimize later

	FOR BoardX FROM 1 TO MatSize(2) DO
		FOR BoardY FROM 1 TO MatSize(1) DO
			NbrTlRow = BoardY - 1;
			NbrTlCol = BoardX - 1;
			NbrBrRow = BoardY + 1;
			NbrBrCol = BoardY + 1;
		
			CurrentCell := CurrentGen(BoardY, BoardX);	

			// If we hit the edges in either direction, fix up 
			// references (assume outer cells are always off
			IF NbrTlRow == 0 THEN
				NbrTlRow = 1;
			END;
			IF NbrTlCol == 0 THEN
				NbrTlCol = 1;
			END;

			IF NbrBrRow > MatSize(1) THEN
				NbrBrRow = MatSize(1);
			END;
			IF NbrBrCol > MatSize(2) THEN
				NbrBrCol = MatSize(2);
			END;

			Nbrs := CurrentGen({{NbrTlRow,NbrTlCol},{NbrBrRow,NbrBrCol}});
			NbrCount := Î£LIST(Nbrs)-1; 

			NextGen(BoardY, BoardX) := 0;	

			IF CurrentCell > 0 THEN
				IF (NbrCount == 2 OR NbrCount == 3) THEN 
					NextGen(BoardY, BoardX) := 1;	
				ELSE
					NextGen(BoardY, BoardX) := 0;	
				END;
			ELSE
				IF (NbrCount == 3) THEN
					NextGen(BoardY, BoardX) := 1;
			END;
		END;
	END;
	RETURN(CurrentGen)
END;

/// MAIN
EXPORT GameOfLife()
BEGIN
   // Size of playing field (square matrix)
   LOCAL FieldSize;
 
   //TODO load this from a user prompt
   FieldSize := 25;

   // SIZE X SIZE matrix of current generation 
   // (this is the generation visible on the screen)
   LOCAL CurrentGen;

   // SIZE x SIZE matrix of next generation. Once computed
   // becomes the current generation and then is zeroed out 
   LOCAL NextGen;

   // Create both  current and next gen matrices as 0 matrices
   CurrentGen := MAKEMAT(0, FieldSize, FieldSize);
   NextGen := MAKEMAT(0, FieldSize, FieldSize);

   CurrentGen := LoadRPentomino(CurrentGen);
   M1 := CurrentGen; // Store in M1 for debugging 
   RETURN(0);
END;
